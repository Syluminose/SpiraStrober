<!--
Copyright (c) 2025 Syluminose
Licensed under the MIT License
-->
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>üåà SpiraStrober</title></head><script>
let d=document,c=z=>d.createElement(z),e=d.documentElement,h=c('head'),b=c('body'),t1=c('h1'),p1=c('p'),t2=c('h2'),bf=c('input'),bflbl=c('label'),amp=c('input'),amplbl=c('label'),ampval=c('span'),globalDur=c('input'),globalDurLbl=c('label'),globalDurBtn=c('button'),randMinFreq=c('input'),randMinFreqLbl=c('label'),randMaxFreq=c('input'),randMaxFreqLbl=c('label'),stat=c('div'),genBtn=c('button'),stopBtn=c('button'),randBtn=c('button'),addBtn=c('button'),add10Btn=c('button'),prog=c('div'),progFill=c('div'),t3=c('h2'),viz=c('div'),leds=c('div'),ll=c('div'),rl=c('div'),llbl=c('span'),rlbl=c('span'),t4=c('h2'),audio=c('audio'),dlBtn=c('button'),tip=c('p'),stepsContainer=c('div'),ctx,buf,pat=[],gen=0;

// Cache pour optimiser les calculs
let freqCache=new Map(), phaseCache=new Map(), stepTimesCache=null, stepParamsCache=null;

let steps=[[10,10,15,0,0.5],[10,20,25,5,1.0],[0,15,30,3,0.8]];
e.appendChild(b);
t1.textContent='üåà SpiraStrober';
p1.textContent='G√©n√©rateur optimis√© avec √©tapes multiples pour transitions complexes';
bf.type='number';bf.value='19200';bf.min='15000';bf.max='20000';
bflbl.textContent='Fr√©quence porteuse (Hz)';
amp.type='range';amp.min='0';amp.max='0.1';amp.step='0.005';amp.value='0.1';
amplbl.textContent='Amplitude';
ampval.textContent='0.1';
stat.textContent='Pr√™t - 3 √©tapes';
genBtn.textContent='üöÄ G√©n√©rer Ultra-Rapide';
stopBtn.textContent='‚èπÔ∏è Stop';
stopBtn.disabled=1;
randBtn.textContent='üéØ Random';
globalDur.type='number';globalDur.value='10';globalDur.min='1';globalDur.max='60';
globalDurLbl.textContent='Dur√©e par √©tape (s)';
globalDurBtn.textContent='üîÑ Appliquer √† Toutes';
globalDurBtn.style.cssText='background:#2196F3;color:white;padding:4px 8px;border:none;border-radius:3px;margin-left:5px;cursor:pointer;font-size:12px';
randMinFreq.type='number';randMinFreq.value='1';randMinFreq.min='1';randMinFreq.max='50';
randMinFreqLbl.textContent='Random Min (Hz)';
randMaxFreq.type='number';randMaxFreq.value='30';randMaxFreq.min='5';randMaxFreq.max='100';
randMaxFreqLbl.textContent='Random Max (Hz)';
addBtn.textContent='üî∂1';
add10Btn.textContent='üî∂10';
add10Btn.style.cssText='background:#9C27B0;color:white;padding:8px 16px;border:none;border-radius:4px;margin:5px;cursor:pointer';
prog.style.cssText='width:100%;height:20px;background:#333;border-radius:10px;margin:10px 0;overflow:hidden;display:none';
progFill.style.cssText='width:0%;height:100%;background:linear-gradient(90deg,#4CAF50,#8BC34A);transition:width 0.3s;border-radius:10px';
prog.appendChild(progFill);
t2.textContent='Param√®tres Globaux';
t3.textContent='Aper√ßu';
viz.style.cssText='height:100px;background:#000;overflow:hidden';
ll.style.cssText='width:30px;height:30px;border-radius:50%;display:inline-block;margin:5px;background:#333;transition:all 0.3s';
rl.style.cssText='width:30px;height:30px;border-radius:50%;display:inline-block;margin:5px;background:#333;transition:all 0.3s';
llbl.textContent='G';
rlbl.textContent='D';
leds.style.textAlign='center';
leds.append(ll,llbl,rl,rlbl);
t4.textContent='Audio';
audio.controls=1;
audio.style.width='80%';
dlBtn.textContent='üíæ WAV';
dlBtn.disabled=1;
tip.textContent='üí° Branchez sur AUX de l'appareil, volume max';
stepsContainer.style.cssText='border:1px solid #666;border-radius:5px;margin:10px 0;padding:10px';
b.append(t1,p1,t2,bflbl,c('br'),bf,c('br'),amplbl,c('br'),amp,ampval,c('br'),c('br'),globalDurLbl,c('br'),globalDur,globalDurBtn,c('br'),c('br'),randMinFreqLbl,randMinFreq,c('br'),randMaxFreqLbl,randMaxFreq,c('br'),c('br'),stepsContainer,c('br'),addBtn,add10Btn,c('br'),stat,prog,randBtn,genBtn,stopBtn,t3,viz,leds,t4,audio,dlBtn,tip);
amp.addEventListener('input',e=>ampval.textContent=e.target.value);

// Optimisation: Pre-calcul des temps de transition
const buildStepTimes=stepParams=>{
    const times=[0];
    let cumulative=0;
    for(let i=0;i<stepParams.length-1;i++){
        cumulative+=stepParams[i][0];
        times.push(cumulative);
    }
    return times;
};

// Optimisation: Recherche binaire pour trouver l'√©tape active
const findStepIndex=(t,stepTimes)=>{
    let left=0,right=stepTimes.length-1;
    while(left<right){
        const mid=(left+right+1)>>1;
        if(stepTimes[mid]<=t)left=mid;
        else right=mid-1;
    }
    return Math.min(left,stepTimes.length-2);
};

// Cache intelligent pour √©viter les recalculs
const getCachedFreq=(t,stepParams,stepTimes,channel)=>{
    const key=`${t.toFixed(6)}_${channel}`;
    if(freqCache.has(key))return freqCache.get(key);
    
    const stepIdx=findStepIndex(t,stepTimes);
    const stepStart=stepTimes[stepIdx];
    const stepEnd=stepTimes[stepIdx+1]||stepTimes[stepIdx]+stepParams[stepIdx][0];
    const stepDur=stepEnd-stepStart;
    
    if(stepDur<=0){
        const freq=stepParams[stepIdx][channel];
        freqCache.set(key,freq);
        return freq;
    }
    
    const tInStep=t-stepStart;
    const progress=tInStep/stepDur;
    const smoothProgress=0.5*(1-Math.cos(Math.PI*progress)); // Interpolation cosinus pour plus de fluidit√©
    
    const freq1=stepParams[stepIdx][channel];
    const freq2=stepParams[stepIdx+1][channel];
    const oscAmp1=stepParams[stepIdx][3];
    const oscAmp2=stepParams[stepIdx+1][3];
    const oscFreq1=stepParams[stepIdx][4];
    const oscFreq2=stepParams[stepIdx+1][4];
    
    const baseFreq=freq1+(freq2-freq1)*smoothProgress;
    const oscAmp=oscAmp1+(oscAmp2-oscAmp1)*smoothProgress;
    const oscFreq=oscFreq1+(oscFreq2-oscFreq1)*smoothProgress;
    
    const osc=oscAmp>0?Math.sin(2*Math.PI*oscFreq*t)*oscAmp:0;
    const finalFreq=Math.max(1,Math.min(100,baseFreq+osc));
    
    freqCache.set(key,finalFreq);
    if(freqCache.size>10000)freqCache.clear(); // Limite le cache
    return finalFreq;
};

// Version ultra-optimis√©e de l'int√©gration de phase
const fastPhaseIntegrate=(t,stepParams,stepTimes)=>{
    const key=`phase_${t.toFixed(6)}`;
    if(phaseCache.has(key))return phaseCache.get(key);
    
    let phase=0,currentTime=0;
    
    for(let i=0;i<stepParams.length-1;i++){
        const stepDur=stepParams[i][0];
        const stepEnd=currentTime+stepDur;
        
        if(t<=currentTime)break;
        
        const segmentStart=Math.max(currentTime,0);
        const segmentEnd=Math.min(t,stepEnd);
        const segmentDur=segmentEnd-segmentStart;
        
        if(segmentDur>0){
            const freq1=stepParams[i][1];
            const freq2=stepParams[i+1][1];
            const oscAmp1=stepParams[i][3];
            const oscAmp2=stepParams[i+1][3];
            const oscFreq1=stepParams[i][4];
            const oscFreq2=stepParams[i+1][4];
            
            // Approximation polynomial pour l'int√©gration rapide
            const avgFreq=(freq1+freq2)*0.5;
            const freqDelta=freq2-freq1;
            
            // Contribution de base avec acc√©l√©ration quadratique
            const tRel=segmentEnd-segmentStart;
            const baseContrib=avgFreq*tRel+freqDelta*tRel*tRel/(2*stepDur);
            
            // Contribution oscillante simplifi√©e
            const avgOscAmp=(oscAmp1+oscAmp2)*0.5;
            const avgOscFreq=(oscFreq1+oscFreq2)*0.5;
            
            if(avgOscAmp>0&&avgOscFreq>0){
                const oscPhase=2*Math.PI*avgOscFreq*segmentStart;
                const oscContrib=-avgOscAmp*Math.sin(oscPhase+Math.PI*avgOscFreq*tRel)/(2*Math.PI*avgOscFreq);
                phase+=baseContrib+oscContrib;
            }else{
                phase+=baseContrib;
            }
        }
        
        currentTime+=stepDur;
        if(t<=currentTime)break;
    }
    
    phaseCache.set(key,phase);
    if(phaseCache.size>5000)phaseCache.clear();
    return phase;
};

const createStepUI=(stepIdx)=>{const step=steps[stepIdx],stepDiv=c('div'),title=c('h3'),removeBtn=c('button'),dur=c('input'),durlbl=c('label'),durval=c('span'),ls=c('input'),lslbl=c('label'),lsval=c('span'),rs=c('input'),rslbl=c('label'),rsval=c('span'),os=c('input'),oslbl=c('label'),osval=c('span'),of=c('input'),oflbl=c('label'),ofval=c('span');
stepDiv.style.cssText='border:2px solid '+(stepIdx===steps.length-1?'#f44':'#4CAF50')+';border-radius:5px;background:'+(stepIdx===steps.length-1?'rgba(255,68,68,0.1)':'rgba(76,175,80,0.1)')+';padding:10px;margin:10px 0;position:relative';
title.textContent=(stepIdx===steps.length-1?'üèÅ Fin':'üìç √âtape '+(stepIdx+1));
title.style.cssText='color:'+(stepIdx===steps.length-1?'#f44':'#4CAF50')+';margin:0 0 10px 0';
removeBtn.textContent='‚ùå';
removeBtn.style.cssText='position:absolute;top:5px;right:5px;background:#f44;color:white;border:none;border-radius:3px;width:25px;height:25px;cursor:pointer;font-size:12px';
removeBtn.disabled=steps.length<=2;
dur.type='range';dur.min=stepIdx===steps.length-1?'0':'1';dur.max=stepIdx===steps.length-1?'0':'120';dur.value=step[0];dur.disabled=stepIdx===steps.length-1;
durlbl.textContent='Dur√©e (s)';
durval.textContent=step[0]+'s';
ls.type='range';ls.min='1';ls.max='100';ls.value=step[1];
lslbl.textContent='Gauche (Hz)';
lsval.textContent=step[1]+' Hz';
rs.type='range';rs.min='1';rs.max='100';rs.value=step[2];
rslbl.textContent='Droite (Hz)';
rsval.textContent=step[2]+' Hz';
os.type='range';os.min='0';os.max='15';os.value=step[3];
oslbl.textContent='Osc Amp (Hz)';
osval.textContent=step[3]+' Hz';
of.type='range';of.min='0.1';of.max='3';of.step='0.1';of.value=step[4];
oflbl.textContent='Osc Freq (Hz)';
ofval.textContent=step[4]+' Hz';
dur.addEventListener('input',e=>{steps[stepIdx][0]=+e.target.value;durval.textContent=e.target.value+'s';updateStatus();stepTimesCache=null;});
ls.addEventListener('input',e=>{steps[stepIdx][1]=+e.target.value;lsval.textContent=e.target.value+' Hz';freqCache.clear();});
rs.addEventListener('input',e=>{steps[stepIdx][2]=+e.target.value;rsval.textContent=e.target.value+' Hz';freqCache.clear();});
os.addEventListener('input',e=>{steps[stepIdx][3]=+e.target.value;osval.textContent=e.target.value+' Hz';freqCache.clear();phaseCache.clear();});
of.addEventListener('input',e=>{steps[stepIdx][4]=+e.target.value;ofval.textContent=e.target.value+' Hz';freqCache.clear();phaseCache.clear();});
removeBtn.onclick=()=>{if(steps.length>2){steps.splice(stepIdx,1);updateStepsUI();stepTimesCache=null;freqCache.clear();phaseCache.clear();}};
stepDiv.append(title,removeBtn,durlbl,c('br'),dur,durval,c('br'),lslbl,c('br'),ls,lsval,c('br'),rslbl,c('br'),rs,rsval,c('br'),oslbl,c('br'),os,osval,c('br'),oflbl,c('br'),of,ofval);
return stepDiv;};

const updateStepsUI=()=>{stepsContainer.replaceChildren();steps.forEach((step,i)=>stepsContainer.appendChild(createStepUI(i)));updateStatus();};
const updateStatus=()=>{const totalDur=steps.slice(0,-1).reduce((sum,step)=>sum+step[0],0);stat.textContent=`Pr√™t - ${steps.length} √©tapes - Dur√©e totale: ${totalDur}s`;};
const addStep=()=>{const lastNonFinal=steps[steps.length-2],finalStep=steps[steps.length-1];steps.splice(-1,0,[10,...lastNonFinal.slice(1)]);updateStepsUI();stepTimesCache=null;};
const add10Steps=()=>{const lastNonFinal=steps[steps.length-2];for(let i=0;i<10;i++){steps.splice(-1,0,[10,...lastNonFinal.slice(1)]);}updateStepsUI();stepTimesCache=null;};
const applyGlobalDuration=()=>{const newDur=+globalDur.value;steps.forEach((step,i)=>{if(i<steps.length-1)step[0]=newDur;});updateStepsUI();stepTimesCache=null;};
const randomize=()=>{const minFreq=+randMinFreq.value,maxFreq=+randMaxFreq.value,freqRange=maxFreq-minFreq;steps=steps.map((step,i)=>i===steps.length-1?[0,Math.floor(Math.random()*freqRange)+minFreq,Math.floor(Math.random()*freqRange)+minFreq,Math.floor(Math.random()*12),(Math.random()*2.5+0.2).toFixed(1)*1]:[step[0],Math.floor(Math.random()*freqRange)+minFreq,Math.floor(Math.random()*freqRange)+minFreq,Math.floor(Math.random()*12),(Math.random()*2.5+0.2).toFixed(1)*1]);updateStepsUI();stepTimesCache=null;freqCache.clear();phaseCache.clear();};
const init=()=>ctx||(ctx=new(window.AudioContext||window.webkitAudioContext)());

// G√©n√©ration de pattern optimis√©e
const genPattern=stepParams=>{
    const totalDur=stepParams.slice(0,-1).reduce((sum,step)=>sum+step[0],0);
    const pts=Math.min(1000,totalDur*25); // R√©duit les points pour plus de rapidit√©
    const ptrn=[];
    
    if(!stepTimesCache)stepTimesCache=buildStepTimes(stepParams);
    
    for(let i=0;i<pts;i++){
        const t=(i/(pts-1))*totalDur;
        const lf=getCachedFreq(t,stepParams,stepTimesCache,1);
        const rf=getCachedFreq(t,stepParams,stepTimesCache,2);
        const lphase=fastPhaseIntegrate(t,stepParams.map(s=>[s[0],s[1],s[2],s[3],s[4]]),stepTimesCache);
        const rphase=fastPhaseIntegrate(t,stepParams.map(s=>[s[0],s[2],s[1],s[3],s[4]]),stepTimesCache);
        const la=(Math.sin(2*Math.PI*lphase)+1)*0.5;
        const ra=(Math.sin(2*Math.PI*rphase)+1)*0.5;
        ptrn.push({time:t,left:la,right:ra,leftFreq:lf,rightFreq:rf});
    }
    return ptrn;
};

const drawPattern=ptrn=>{if(!ptrn.length)return;const w=viz.clientWidth,h=viz.clientHeight,can=c('canvas'),ct=can.getContext('2d');can.width=w;can.height=h;can.style.cssText='width:100%;height:100%';viz.replaceChildren(can);ct.fillStyle='#000';ct.fillRect(0,0,w,h);ct.strokeStyle='#f44';ct.lineWidth=1;ct.beginPath();const maxTime=ptrn[ptrn.length-1].time;ptrn.forEach((pt,i)=>{const x=(pt.time/maxTime)*w,y=h-(pt.left*h*0.4)-h*0.1;i?ct.lineTo(x,y):ct.moveTo(x,y);});ct.stroke();ct.strokeStyle='#4f4';ct.beginPath();ptrn.forEach((pt,i)=>{const x=(pt.time/maxTime)*w,y=h-(pt.right*h*0.4)-h*0.6;i?ct.lineTo(x,y):ct.moveTo(x,y);});ct.stroke();let currentTime=0;steps.slice(0,-1).forEach((step,i)=>{const x=(currentTime/maxTime)*w;ct.strokeStyle='#fff';ct.setLineDash([5,5]);ct.beginPath();ct.moveTo(x,0);ct.lineTo(x,h);ct.stroke();ct.setLineDash([]);currentTime+=step[0];});ct.fillStyle='#f44';ct.font='12px Arial';ct.fillText('G:'+ptrn[ptrn.length-1].leftFreq.toFixed(1)+'Hz',10,20);ct.fillStyle='#4f4';ct.fillText('D:'+ptrn[ptrn.length-1].rightFreq.toFixed(1)+'Hz',10,h-10);};
const animLEDs=ptrn=>{let i=0;(function upd(){if(!gen||i>=ptrn.length)i=0;if(ptrn[i]){const pt=ptrn[i],lb=Math.floor(pt.left*255),rb=Math.floor(pt.right*255);ll.style.background=`rgb(${lb},0,0)`;rl.style.background=`rgb(0,${rb},0)`;i++;}setTimeout(upd,100);})();};

// Version ultra-optimis√©e de la g√©n√©ration audio
const generate=()=>{
    if(gen)return;
    init();
    gen=1;
    
    const baseFreq=+bf.value;
    const amplitude=+amp.value;
    const totalDur=steps.slice(0,-1).reduce((sum,step)=>sum+step[0],0);
    
    if(totalDur===0){
        stat.textContent='Erreur: Dur√©e totale nulle';
        gen=0;
        return;
    }
    
    const sr=44100;
    const samp=totalDur*sr;
    genBtn.disabled=1;
    stopBtn.disabled=0;
    prog.style.display='block';
    progFill.style.width='0%';
    stat.textContent='G√©n√©ration ultra-rapide...';
    
    // Nettoie les caches pour cette g√©n√©ration
    freqCache.clear();
    phaseCache.clear();
    
    if(!stepTimesCache)stepTimesCache=buildStepTimes(steps);
    
    pat=genPattern(steps);
    drawPattern(pat);
    animLEDs(pat);
    
    const lc=new Float32Array(samp);
    const rc=new Float32Array(samp);
    
    // Optimisation: traitement par chunks plus gros avec Web Workers simul√©
    const chunkSize=sr; // 1 seconde par chunk
    let currentChunk=0;
    const totalChunks=Math.ceil(samp/chunkSize);
    
    // Pre-calcul des constantes
    const PI2=2*Math.PI;
    const baseFreqPI2=PI2*baseFreq;
    
    const processChunk=()=>{
        const start=currentChunk*chunkSize;
        const end=Math.min(start+chunkSize,samp);
        const startTime=performance.now();
        
        // Traitement vectoris√© du chunk
        for(let i=start;i<end;i+=4){ // Traitement par blocs de 4
            const blockEnd=Math.min(i+4,end);
            for(let j=i;j<blockEnd;j++){
                const t=j/sr;
                
                const lfreq=getCachedFreq(t,steps,stepTimesCache,1);
                const rfreq=getCachedFreq(t,steps,stepTimesCache,2);
                
                const lphase=fastPhaseIntegrate(t,steps.map(s=>[s[0],s[1],s[2],s[3],s[4]]),stepTimesCache);
                const rphase=fastPhaseIntegrate(t,steps.map(s=>[s[0],s[2],s[1],s[3],s[4]]),stepTimesCache);
                
                const lm=(Math.sin(PI2*lphase)+1)*0.5;
                const rm=(Math.sin(PI2*rphase)+1)*0.5;
                
                const carPhase=baseFreqPI2*t;
                const car=Math.sin(carPhase);
                
                lc[j]=car*lm*amplitude;
                rc[j]=car*rm*amplitude;
            }
        }
        
        currentChunk++;
        const progress=(currentChunk/totalChunks)*100;
        progFill.style.width=progress+'%';
        
        // Estimation du temps restant
        const elapsed=performance.now()-startTime;
        const remaining=((totalChunks-currentChunk)*elapsed/1000).toFixed(1);
        if(remaining>0.1)stat.textContent=`G√©n√©ration ultra-rapide... ${Math.round(progress)}% (${remaining}s restantes)`;
        
        if(currentChunk<totalChunks&&gen){
            // Utilise requestIdleCallback si disponible pour une meilleure performance
            if(window.requestIdleCallback){
                requestIdleCallback(processChunk,{timeout:16});
            }else{
                setTimeout(processChunk,0);
            }
        }else{
            finishGen();
        }
    };

    const finishGen=()=>{
        if(!gen)return;
        buf=ctx.createBuffer(2,samp,sr);
        buf.copyToChannel(lc,0);
        buf.copyToChannel(rc,1);
        const ab=bufToWav(buf);
        const bl=new Blob([ab],{type:'audio/wav'});
        const url=URL.createObjectURL(bl);
        audio.src=url;
        dlBtn.disabled=0;
        genBtn.disabled=0;
        stopBtn.disabled=1;
        prog.style.display='none';
        stat.textContent=`üöÄ Ultra-g√©n√©r√©! ${steps.length} √©tapes, ${totalDur}s, ${samp} √©chantillons`;
        gen=0;
    };
    
    processChunk();
};

const stopGen=()=>{gen=0;genBtn.disabled=0;stopBtn.disabled=1;prog.style.display='none';stat.textContent='Arr√™t√©';};
const bufToWav=buffer=>{const len=buffer.length,nc=buffer.numberOfChannels,sr=buffer.sampleRate,ab=new ArrayBuffer(44+len*nc*2),v=new DataView(ab),ws=(offset,string)=>[...string].forEach((c,i)=>v.setUint8(offset+i,c.charCodeAt(0)));ws(0,'RIFF');v.setUint32(4,36+len*nc*2,1);ws(8,'WAVE');ws(12,'fmt ');v.setUint32(16,16,1);v.setUint16(20,1,1);v.setUint16(22,nc,1);v.setUint32(24,sr,1);v.setUint32(28,sr*nc*2,1);v.setUint16(32,nc*2,1);v.setUint16(34,16,1);ws(36,'data');v.setUint32(40,len*nc*2,1);let offset=44;for(let i=0;i<len;i++)for(let ch=0;ch<nc;ch++){const samp=Math.max(-1,Math.min(1,buffer.getChannelData(ch)[i]));v.setInt16(offset,samp<0?samp*0x8000:samp*0x7FFF,1);offset+=2;}return ab;};
const download=()=>{if(!buf)return;const ab=bufToWav(buf),bl=new Blob([ab],{type:'audio/wav'}),url=URL.createObjectURL(bl),a=c('a');a.href=url;a.download='audiostrobe_ultrabrapide_'+Date.now()+'.wav';a.click();URL.revokeObjectURL(url);};

genBtn.onclick=generate;
stopBtn.onclick=stopGen;
dlBtn.onclick=download;
randBtn.onclick=randomize;
addBtn.onclick=addStep;
add10Btn.onclick=add10Steps;
globalDurBtn.onclick=applyGlobalDuration;
updateStepsUI();
setTimeout(()=>{randomize();setTimeout(generate,500);},100);
</script></html>